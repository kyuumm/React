使用CRA初始化项目环境
1.使用CRA创建项目
npx create-react-app react-jike
2.按照业务规范整理项目目录(重点SRC目录)
规范目录：
Src
	apis                 接口
	assets              静态资源
	components   通用组件
	pages              页面级组件
	router              路由router
	store                redux状态
	utils                 工具函数
	App.js
	index.js
	index.scss

SCSS是什么
SCSS是一种后缀名为.scss的预编译CSS语言，支持一些原生CSS不支持的高级用法，比如变量使用，嵌套语法等，使用SCSS可以让样式代码更加高效灵活
安装：
1.npm install sass -D
2.测试.scss文件是否可用(嵌套语法)

style.scss -> sass -> style.css
sass负责编译转化成css，开发阶段使用scss

6-04-Router
配置基础路由Router
配置步骤
1.安装路由包 react-router-dom
2.准备俩个基础路由组件 Layout 和 Login
3.在router/index.js文件中引入组件进行路由配置，导出router实例
4.在入口文件中渲染<RouterProvider/>，传入router实例
index.js --导入-->RouterProvider---使用--->router配置
indexjs---导入---》router配置

RouterProvider 的作用：
这是 react-router-dom 提供的核心组件
用于在整个应用中启用路由功能
它接收一个 router 配置对象作为属性
负责根据 URL 匹配并渲染对应的组件


DAY6-05-@配置别名路径
如何配置?
1.针对路径转换，修改webpack别名路径配置craco
2.针对联想提示，修改VSCode配置jsconfig.json

GAY6-07-antD组件 
DAY6-08-表单校验
DAY6-09-onFinish提交表单收集数据
DAY6-10-axios封装，request封装
DAY6-11-redux管理token
1.Redux中编写获取Token的异步获取和同步修改
2.Login组件负责提交action并且把表单数据传递过来

DAY6-14-Token持久化
未知原因，Redux工具查看state为null，但是token可以正常输出

DAY6-15-封装Token的存取删除

setToken
getToken
removeToken

utils/token.js

DAY7-01-axios请求拦截器注入Token
为什么要做这件事儿?
Token作为用户的一个标识数据，后端很多接口都会以它作为接口权限判断的依据;请求拦截器注入Token之后，所有用到Axios实例的接口请求都自动携带了Token
utils/request.js
|
axios (token统一注入)
/ |  \
获取用户信息接口
文章发布接口
获取频道接口


方法：
Axios请求拦截器请求头中注入Token
调用接口测试Token是否成功携带
DAY7-02-使用Token做路由权限控制

DAY7-02-根据Token控制路由跳转
1创建组件AuthRoute
export function AuthRoute({ children }) {
  const token = getToken();
  if (token) {
    return <>{children}</>
  } else {
    return <Navigate to={'/login'} replace />
  }
}
2，去Router中配置，包裹原界面
  {
    path: "/",
    element: <AuthRoute><Layout /></AuthRoute>
  },


DAY7-03-Layout样式创建
样式很奇怪，和浏览器自带的样式冲突了，需要reset
使用Normalize第三方库
npm i normalize.css

DAY7-04-Layout二级路由配置
流程：
准备三个二级路由 -- router中通过children配置项进行配置 -- Layout组件中配置二级路由出口
文档和视频不太一样。。？貌似是更新了
//二级路由
const router = createBrowserRouter([
  {
    path: "/",
    element: <AuthRoute><Layout /></AuthRoute>,
    children: [
      {
        path: 'home',
        element: <Home />
      },
      {
        path: 'article',
        element: <Article />
      },
      {
        path: 'publish',
        element: <Publish />
      },
    ]
  },
  {
    path: "/login",
    element: <Login />
  }
])

Layout内写二级路由的出口

DAY7-07-高亮&用户个人信息显示
在store内部新建state，set，fetch的相关方法，在layout内触发更新dispatch，useSelector获取信息
关键问题:用户信息应该放到哪里维护?和Token令牌类似，用户的信息通常很有可能在多个组件中都需要共享使用，所以同样应该放到Redux中维护

使用Redux进行信息管理---Layout组件中提交action---Layout组件中完成渲染 

DAY7-08-退出登录
确认退出登录 ---写redux函数改变state --回调函数中调用函数，导航到登录页

DAY7-09-token失效
token失效后请求接口，后端会返回401状态码，
axios拦截监控401状态码，清除失效token，跳转登录

DAY7-10-Echarts
从官网导入，使用useEffect
DOM 渲染时机：
React 组件的渲染分为两个阶段：render 阶段和 commit 阶段
return 语句中的 JSX 是在 render 阶段执行的
useEffect 中的代码是在 commit 阶段之后执行的，此时 DOM 已经更新到页面上
使用useEffect，内部写echart的渲染


DAY7-11-Echarts组件封装
JSX语法注意！return多行语句需要( )括住
√ return <div><BarChart /></div>
√ return (
  <div>
    <BarChart />
  </div>
)
√ return <div>
    <BarChart />
  </div>
//////
× return 
<div>
  <BarChart />
</div>

CharRef是什么
charRef 是通过 useRef 创建的一个 React ref 对象
它用于直接访问 DOM 元素，是 React 推荐的方式
ref 对象在组件的整个生命周期内保持不变

const charRef = useRef(null);
// 在 JSX 中绑定
return <div ref={charRef} />;
// 在 useEffect 中访问
const chartDom = charRef.current;

DAY7-12-api模块封装
接口请求放到了功能实现的位置，没有再固定的模块内维护，后期查找维护困难
把项目中的所有接口以函数的形式封装到apis模块中

原来：const fetchLogin = (loginForm) => {
  return async (dispatch) => {
    //1 send
    const res = await request.post('/authorizations', loginForm);//**********
    const token = res?.data?.data?.token ?? res?.data?.token;

    dispatch(setToken(token));
  }
}

现在：
const fetchLogin = (loginForm) => {
  return async (dispatch) => {
    //1 send
    const res = await loginAPI(loginForm); //************
    const token = res?.data?.data?.token ?? res?.data?.token;

    dispatch(setToken(token));
  }
}
//apis/user.js

export function loginAPI(formData) {
  return request({
    url: '/authorizations',
    method: "POST",
    data: formData
  })
}

DAY8-02-导入富文本编辑器
npm i react-quill --legacy-peer-deps依赖有问题加上后面那句

DAY8-03-和富文本编辑器冲突，回退react版本
*packagejson修改版本后，执行npm  install
*发现出现两个富文本编辑器，原因：严格模式会渲染两次组件，删<React.StrictMode>

**为什么使用useEffect
组件生命周期：useEffect 可以在组件挂载时执行一些初始化操作，类似于类组件中的 componentDidMount。通过将数据获取放在 useEffect 中，可以确保在组件首次渲染到 DOM 后才进行数据获取，而不是在渲染过程中进行。
为什么不能直接调用 函数getChannelAPI： 
避免阻塞渲染：如果直接在组件函数中调用 getChannelAPI，并且该函数是异步的，可能会导致渲染过程被阻塞，影响用户体验。

DAY8-06-图片上传
在Upload组件中写
                listType="picture-card"
                showUploadList
                action={'http://geek.itheima.net/v1_0/upload'}这里配置上传的接口地址
                onChange={onChange}   //上传图片中不断执行
                name='image'   //按后端的接口文档，需要一个字段

声明State，写onChange回调函数

DAY8-09-发布文章
检测图片数量契合模式与否
没有解决：发布后清空表单，跳转主页

DAY8-11-自定义hook渲染列表

DAY9-1-筛选文章

筛选功能的本质:给请求列表接口传递不同的参数和后端要不同的数据实现步骤:
1.准备完整的请求参数对象
2.获取用户选择的表单数据
3.把表单数据放置到接口对应的字段中
4.重新调用文章列表接口渲染Table列表

DAY9-2-文章分页
实现效果:点击页数，在Table中显示当前页的数据列表
如何实现:
1.实现分页展示(页数=总数/每页条数)
2.点击分页拿到当前点击的页数
3.使用页数作为请求参数重新获取文章列表渲染

      <Card title={`根据筛选条件共查询到 ${count} 条结果：`}>
        <Table rowKey="id" columns={columns} dataSource={list} pagination={{
          total: count,//总数
          pageSize: reqData.per_page, //每条的页数
          onChange: onPageChange,
        }} />
      </Card>

点击后重新渲染
  const onPageChange = (page) => {
    // console.log(page);
    setReqData({
      ...reqData,
      page: page
    })
  }

DAY9-03-文章删除
1.点击删除弹出确认框                
           <Popconfirm
              title="删除文章"
              description="确认删除文章"
              onConfirm={onConfirm}
              okText="是的"
              cancelText="否"
            >
              <Button
                type="primary"
                danger
                shape="circle"
                icon={<DeleteOutlined />}
              />
            </Popconfirm>
2.得到文章id，使用id调用删除接口
    {
      title: '操作',
      render: data => {         //data这里有id
        return (
          <Space size="middle">
            <Button type="primary" shape="circle" icon={<EditOutlined />} />
            <Popconfirm
              title="删除文章"
              description="确认删除文章"
              onConfirm={() => onConfirm(data)}      //传给回调函数
              okText="是的"
              cancelText="否"
            >·········
3.更新文章列表
回调函数内
  const onConfirm = async (data) => {
    console.log(data);
    await delArticleAPI(data.id);        
                                          //不加async await：异步操作，不等待del操作完成继续下一步，列表还没来得及变
    //刷新列表
    setReqData({
      ...reqData,
    })

  }


DAY9-04-编辑跳转
按钮回调函数navigate，携带id跳转网址
            <Button type="primary" shape="circle" icon={<EditOutlined />} onClick={() => navigate(`/publish?id=${data.id}`)} />
 
DAY9-05-数据回显
  //回填数据
  const [searchParams] = useSearchParams()
  const articleId = searchParams.get('id')
            //searchParams.get('id')用于获取URL中名为"id"的查询参数值。例如，如果URL是/publish?id=123，那么articleId的值就是"123"。
  useEffect(() => {
    //1 id获取数据

    //2 实例方法
  })

//

  //获取文章详情
  const [form] = Form.useForm(); //获取Form数据，绑定在form变量上

  useEffect(() => {
    //1 id获取数据
    async function getArticleDetail() {
      const res = await getArticleById(articleId)
      console.log(res.data.data);

      form.setFieldsValue(res.data.data)

    }
    getArticleDetail()
    //2 实例方法


  }, [articleId, form])

********
        <Form
          labelCol={{ span: 4 }}
          wrapperCol={{ span: 16 }}
          initialValues={{ imageType: 0 }}
          onFinish={onFinish}
          form={form}      //绑定变量和Form表单
        >