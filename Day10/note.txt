DAY10-01-useReducer
//1.定义reducer函数 根据不同的action返回不同的状态
function reducer(state, action) {
  switch (action.type) {
    case 'INC':
      return state + 1
    case 'DEC':
      return state - 1;
    default:
      return state;
  }
}

function App() {
  // 2.组件中调用useReducer(reducer，0) => [state,dispatch]
  const [state, dispatch] = useReducer(reducer, 0)
  return (
    // 3.调用dispatch({type:'INC'}) =>通知reducer产生一个新的状态 使用这个新状态更新UI
    <div className="App">
      <button onClick={() => dispatch({ type: "DEC" })}>-</button>
      {state}
      <button onClick={() => dispatch({ type: "INC" })}>+</button>
    </div>
  );
}

传参的写法：
    case 'SET':
      return action.payload;


      <button onClick={() => dispatch({ type: "SET", payload: 100 })}>100</button>
设置payload即可

DAY10-02-useMemo

useMemo
作用:在组件每次重新渲染的时候缓存计算的结果

和useEffect？，
useMemo：在渲染中同步执行
useEffect：渲染之后异步执行，无论 useEffect 里的逻辑多耗时，都不会阻塞页面渲染，用户体验更好

useMemo -基础语法
useMemo(() => {
//根据count1返回计算的结果
},[count1])3

说明:使用useMemo做缓存之后可以保证只有count1依赖项发生变化时才会重新计算

eg：
组件中有count1，count2变量，调用fib(count1)函数，输出结果，当count2变化时，无论count2是否有变化，fib(count1)都会重新计算输出，浪费性能

前：
function fib(n) {
···}

function App() {
 
  const [count1, setCount1] = useState(0);

 const result = fib(count1)

  const [count2, setCount2] = useState(0);
  console.log('rendered again');

  return (···）

改后核心：

  const result = useMemo(() => {
    return fib(count1)
  }, [count1])

DAY10-03-React memo

作用:允许组件在Props没有改变的情况下跳过渲染
React组件默认的渲染机制:只要父组件重新渲染子组件就会重新渲染
如果Son组件本身并不需要做渲染更新，存在浪费

语法：
const MemoComponent = memo(function SomeComponent (props) {
})
说明:经过memo函数包裹生成的缓存组件只有在props发生变化的时候才会重新渲染

eg：

function Child() {
  console.log("Child Rendered");

  return <div>Child</div>
}
function App() {
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count:{count}</button>
      <Child />
//点击按钮，子组件也渲染
    </div>
  );
}

改后：

//子组件使用memo
const MemoChild = memo(
  function Child() {
    console.log("Child Rendered");

    return <div>Child</div>
  }
)
/* function Child() {
  console.log("Child Rendered");

  return <div>Child</div>
} */
function App() {
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count:{count}</button>
      <MemoChild /> //更换组件

DAY10-04-memo props比较

React.memo -props的比较机制
机制:在使用memo缓存组件之后，React会对每一个 prop使用Object.is比较新值和老值，返回true，表示没有变化
prop是简单类型
Object.is(3,3)=>true没有变化
prop是引用类型(对象/数组)
Object([],[])=>false 有变化,React只关心引用是否变化（每次生成新值，不一样）

简单数据类型eg：
const MemoChild = memo(
  function Child({ count }) {
    console.log("Child Rendered");

    return <div>Child {count}</div>
  }
)
/* function Child() {
  console.log("Child Rendered");

  return <div>Child</div>
} */
function App() {
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count</button>
      <MemoChild count={count} />
    </div>
  );
}//点击按钮，重新渲染

改后：
function App() {
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count</button>
      <MemoChild count={100} />
    </div>
  );
}
//点击按钮，不变

引用数据类型eg：

const MemoChild = memo(
  function Child({ list }) {
    console.log("Child Rendered");

    return <div>Child {list}</div>
  }
)
/* function Child() {
  console.log("Child Rendered");

  return <div>Child</div>
} */
function App() {
  const list = [1, 2, 3, 4, 5]
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count</button>
      <MemoChild list={list} />
    </div>
  );
}

点击按钮引发亲组件重新渲染，list会重新生成，两次list引用不一致，重新渲染

解决：
//3.保证引用稳定 ->useMemo 组件渲染的过程中缓存一个值
改后：
function App() {
  const list = useMemo(() => [1, 2, 3, 4, 5], []); //useMemo缓存list的值
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count</button>
      <MemoChild list={list} />
    </div>
  );
}

DAY10-05-useCallback

useCallback
作用:在组件多次重新渲染的时候缓存函数
类似useMemo，对函数的引用进行缓存

const changeHandler = (value) => console.log(value)
改后：
const changeHandler=useCallback((value)=>console.log(value),[ ] )

DAY10-06-forwardRef

通过ref获取到子组件内部的input元素让其聚焦亲组件

const Input = forwardRef((props, ref) => {return <input type="text"ref={ref} />
})
//父组件
function App () {
const inputRef = useRef(null)
return (<>
<Input ref={inputRef} />
<>
)

没懂有什么用

DAY10-07-useInperativeHandle
uselnperativeHandlle -场景说明
父组件 通过ref调用子组件内部的focus方法实现聚焦
子组件
focus
<input/>

*****uselnperativeHandlle -场景说明
//子组件
const Input = forwardRef((props,ref)=>{
	const inputRef = useRef(null)
//实现聚焦逻辑函数
	const focusHandler = ()=>{inputRef.current.focus()}
// 暴露函数给父组件调用,return一个对象，里面放需要暴露的函数
	useImperativeHandle( ref , () => {
		return { focusHandler }
	})
	return <input type="text"ref={inputRef} />
})

在亲组件中,
const focusHandler=()=>{
	sonRef.current.focusHandler( );
//直接调用相应函数
}

DAY10-08-class组件

class Counter extends Component {
  // 编写组件的逻辑代码
  // 1.状态变量 
  state = {
    count: 0
  }
  // 2.事件回调
  setCount = (count) => {
    this.setState({
      count: this.state.count + 1
    })
  }
  // 3.UI(JSX)渲染
  render() {
    return <button onClick={this.setCount}>{this.state.count}</button>
  }
}

function App() {

  return (
    <>
      <Counter />
    </>
  )
}
适合一些老项目
继承于基类
DAY10-09-类组件生命周期函数

import { Component } from "react"
class Child extends Component
// 声明周期函数
//组件渲染完毕执行一次 发送网络请求
componentDidMount () {
console.log('组件渲染完毕了，请求发送起来')
this.timer=setInterval( ()=>{
```
},1000 )
}

//组件卸载时候自动执行  用于副作用清理的工作 清除定时器 清除事件绑定
componentWillUnmont(){
clearInterval(this.timer)
}

render () {
return <div>i am Child</div>

function App () {return (
<Son />
export default App

DAY10-10-类组件的组件通信

类组件的组件通信
概念:类组件和Hooks编写的组件在组件通信的思想上完全一致

*****1.父传子:通过prop绑定数据,传给子组件的是 【数据 / 变量】

//子组件
class Son extends Component
	render () {
	//使用this.props.msg
	return <div>我是子组件 {this.props.msg}</div>
}
// 父组件
class Parent extends Component {
	state = {msg: 'this is parent msg'}
	render () {
		return <div>我是父组件<Son msg={this.state.msg} /></div>

****2.子传父:通过prop绑定组件中的函数，子组件调用,传给子组件的是 【函数 / 方法】

//子组件
class Son extends Component
	render () {
	//使用this.props.msg
	return <div>我是子组件 {this.props.msg}</div>
			<button onClick= { ()=>this.props.onGetSonMsg('im child msg') } >click here<button/>
}
// 父组件
class Parent extends Component {
	state = {msg: 'this is parent msg'}
	getSonMsg=( childMsg )=>{
	~~~
	}
	render () {
		return <div>我是父组件<Son msg={this.state.msg} onGetSonMsg={this.getSonMsg}  /></div>

3.兄弟通信:状态提升，通过父组件做桥接
把兄弟俩要互相传递的「数据」，放到共同的父组件的 state 里存着 
父组件当中间人，就是【子传父】 + 【父传子】的拼接

import { Component } from 'react'
// 兄：Son1 发送数据
class Son1 extends Component {
  render() {
    return (
        <button onClick={()=>{this.props.sendData('兄的数据：hello 老弟')}}>传给弟弟数据</button>
      </div>)}}

// 弟：Son2 接收数据
class Son2 extends Component {
  render() {
    return (
        哥哥传来的数据：{this.props.brotherData}
      </div>)}}

// 共同父组件：只做【中间人】
class Parent extends Component {
  state = { data: '暂无数据' } // 状态提升：存兄弟要传递的数据
  // 步骤1：接收Son1的数据（子传父）
  getSon1Data = (data) => {
    this.setState({ data }) // 存到父的state里}
  render() {
    return (
      <div>我是父组件（中间人）<br/>
        {/* 给Son1传【函数】→ 子传父准备 */}
        <Son1 sendData={this.getSon1Data} />
        {/* 给Son2传【数据】→ 父传子 */}
        <Son2 brotherData={this.state.data} />
      </div>)}}

DAY10-11-zustand