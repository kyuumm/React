DAY10-01-useReducer
//1.定义reducer函数 根据不同的action返回不同的状态
function reducer(state, action) {
  switch (action.type) {
    case 'INC':
      return state + 1
    case 'DEC':
      return state - 1;
    default:
      return state;
  }
}

function App() {
  // 2.组件中调用useReducer(reducer，0) => [state,dispatch]
  const [state, dispatch] = useReducer(reducer, 0)
  return (
    // 3.调用dispatch({type:'INC'}) =>通知reducer产生一个新的状态 使用这个新状态更新UI
    <div className="App">
      <button onClick={() => dispatch({ type: "DEC" })}>-</button>
      {state}
      <button onClick={() => dispatch({ type: "INC" })}>+</button>
    </div>
  );
}

传参的写法：
    case 'SET':
      return action.payload;


      <button onClick={() => dispatch({ type: "SET", payload: 100 })}>100</button>
设置payload即可

DAY10-02-useMemo

useMemo
作用:在组件每次重新渲染的时候缓存计算的结果

和useEffect？，
useMemo：在渲染中同步执行
useEffect：渲染之后异步执行，无论 useEffect 里的逻辑多耗时，都不会阻塞页面渲染，用户体验更好

useMemo -基础语法
useMemo(() => {
//根据count1返回计算的结果
},[count1])3

说明:使用useMemo做缓存之后可以保证只有count1依赖项发生变化时才会重新计算

eg：
组件中有count1，count2变量，调用fib(count1)函数，输出结果，当count2变化时，无论count2是否有变化，fib(count1)都会重新计算输出，浪费性能

前：
function fib(n) {
···}

function App() {
 
  const [count1, setCount1] = useState(0);

 const result = fib(count1)

  const [count2, setCount2] = useState(0);
  console.log('rendered again');

  return (···）

改后核心：

  const result = useMemo(() => {
    return fib(count1)
  }, [count1])

DAY10-03-React memo

作用:允许组件在Props没有改变的情况下跳过渲染
React组件默认的渲染机制:只要父组件重新渲染子组件就会重新渲染
如果Son组件本身并不需要做渲染更新，存在浪费

语法：
const MemoComponent = memo(function SomeComponent (props) {
})
说明:经过memo函数包裹生成的缓存组件只有在props发生变化的时候才会重新渲染

eg：

function Child() {
  console.log("Child Rendered");

  return <div>Child</div>
}
function App() {
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count:{count}</button>
      <Child />
//点击按钮，子组件也渲染
    </div>
  );
}

改后：

//子组件使用memo
const MemoChild = memo(
  function Child() {
    console.log("Child Rendered");

    return <div>Child</div>
  }
)
/* function Child() {
  console.log("Child Rendered");

  return <div>Child</div>
} */
function App() {
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count:{count}</button>
      <MemoChild /> //更换组件

DAY10-04-memo props比较

React.memo -props的比较机制
机制:在使用memo缓存组件之后，React会对每一个 prop使用Object.is比较新值和老值，返回true，表示没有变化
prop是简单类型
Object.is(3,3)=>true没有变化
prop是引用类型(对象/数组)
Object([],[])=>false 有变化,React只关心引用是否变化（每次生成新值，不一样）

简单数据类型eg：
const MemoChild = memo(
  function Child({ count }) {
    console.log("Child Rendered");

    return <div>Child {count}</div>
  }
)
/* function Child() {
  console.log("Child Rendered");

  return <div>Child</div>
} */
function App() {
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count</button>
      <MemoChild count={count} />
    </div>
  );
}//点击按钮，重新渲染

改后：
function App() {
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count</button>
      <MemoChild count={100} />
    </div>
  );
}
//点击按钮，不变

引用数据类型eg：

const MemoChild = memo(
  function Child({ list }) {
    console.log("Child Rendered");

    return <div>Child {list}</div>
  }
)
/* function Child() {
  console.log("Child Rendered");

  return <div>Child</div>
} */
function App() {
  const list = [1, 2, 3, 4, 5]
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count</button>
      <MemoChild list={list} />
    </div>
  );
}

点击按钮引发亲组件重新渲染，list会重新生成，两次list引用不一致，重新渲染

解决：
//3.保证引用稳定 ->useMemo 组件渲染的过程中缓存一个值
改后：
function App() {
  const list = useMemo(() => [1, 2, 3, 4, 5], []); //useMemo缓存list的值
  const [count, setCount] = useState(0);
  return (
    <div className="App">
      <button onClick={() => { setCount(count + 1) }}>count</button>
      <MemoChild list={list} />
    </div>
  );
}
