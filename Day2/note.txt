//受控绑定
1.声明一个react状态-useState
2.核心绑定流程

1.通过value属性绑定react状态
2.绑定onChange事件 通过事件参数e拿到输入框最新的值 反向修改到react状态
const [value,setValue]=useState('')
<input value={value} type='text' onChange=(e)=>setValue(e.target.value)>

</input>

1.useRef生成ref对象 绑定到dom标签身上
2.dom可用时，ref.current获取dom
渲染完毕之后dom生成才可用

import {useState,useRef} from 'react'

const inputRef=useRef(null)
const showDom=()=>{
  console.log(inputRef.current)
}

return 
<input type='text' ref={inputRef}>
<button onClick={showDom}>get dom</button>
</input>

母子通信
function Child(props){
  return <div>this is child ,{props.ChildName},标签:{props.grandChild}</div>
}

1.props可传递任意的数据数字、字符串、布尔值、数组、对象、函数、JSX
function Parent(){
  const name='this is parent'
  return (
    <div>
      <Child ChildName={name}
        age={18}
      grandChild={<span>this is grandChild</span>}
      />
    </div>


    <Child>
      <span>this is span</span>
    </Child>
在 <Child> ... </Child> 标签包裹的内容
会被自动放到 props.children 里
  )
}
子组件只能读取props中的数据，不能直接进行修改,亲组件的数据只能由亲组件修改

真恶心啊父子名称，为什么这么翻译？

父子组件通信：子传父：在子组件中调用父组件中的函数并传递参数
function Child({onGetChildMsg}){
  const ChildMsg='this is childs msg'
  return (
    <div>
    <button onClick={()=>onGetChildMsg(ChildMsg)}>  lickhere  </button>
    </div>
  )
}

function Parent(){
  const [msg,setMsg]=useState('')
  const getMsg=(msg)=>{
    console.log(msg);
    setMsg(msg)
  }

  const name='this is parent'

  return (
    <div>
      {msg}
      <Child 
        onGetChildMsg={getMsg}
      />
    </div>
)}

-------------兄弟通信

import { useState } from "react"

function A({ onGetAName }) {
  const name = 'this is A name'
  return (
    <div>
      this is A component,
      <button onClick={() => onGetAName(name)}>send</button>
    </div>
  )
}

function B({ name }) {
  return (
    <div>
      this is B component,
      {name}
    </div>
  )
}

function App() {
  const [name, setName] = useState('')

  const getAName = (name) => {
    console.log(name)
    setName(name)
  }

  return (
    <div>
      <A onGetAName={getAName} />
      <B name={name} />
    </div>
  )
}

A 不能直接跟 B 说话，所以 A 把消息交给共同的父亲 App，
App 把这条消息存进自己的 state，再转手交给 B。

父子通信（props）：父 ➜ 子：<Child msg={xxx} />

子父通信（回调）：子 ➜ 父：子调用父传下来的函数

兄弟通信：

A ➜ 父（回调）

父用 useState 记住

父 ➜ B（props）

说白了，所有复杂写法，都绕不过这三步：props + 回调 + useState。

这个东西叫状态提升


//App->A->B
1createContext 创建上下文对象

const MsgContext=createContext()

2顶层组件通过provider组件提供数据
3底层组件通过useContext钩子函数使用数据

function A() {
  return (
    <div>
      this is A component,
      <B/>
    </div>
  )
}

function B() {
  const msg=useContext(MsgContext)
  return (
    <div>
      this is B component,{msg}
    </div>
  )
}

function App() {
 const msg='this is app msg'
  return (
    <div>
      <MsgContext.Provider value={msg}>
      this is App
      <A />
      <MsgContext.Provider>
    </div>
  )
}

------------useEffect
import { useEffect, useState } from "react";
const URL = 'http://geek.itheima.net/v1_0/channels'

function App() {
  const [list, setList] = useState([]);

  useEffect(() => {
    //额外的操作，获取频道列表
    async function getList() {
      const res = await fetch(URL);//fetch发起网络请求，请求频道列表
      const jsonRes = await res.json()//把响应体解析成 JSON

      console.log(jsonRes);
      setList(jsonRes.data.channels)//修改 list 这块 state，触发组件重新渲染
    }

    getList();

  }, [])
  //是空数组，回调函数只执行一次
  return (
    <div>
      this is App
      <ul>
        {list.map(item => <li key={item.id}>{item.name}</li>)}
      </ul>

    </div>
  );
}

export default App;
React 调用 App()：

list 初始为 []

JSX 渲染 <ul>空列表</ul>

首次渲染完成后，React 运行 useEffect 里的回调：

定义 getList

调用 getList() 去请求接口

请求回来后：

setList(jsonRes.data.channels)

触发组件重新渲染

React 再次调用 App()：

这次 list 是一个有数据的数组

调用App--list渲染为空--回调useEffect--获取数据后传递给list--setlist修改值--重新渲染

async和await逻辑：等价于
useEffect(() => {
  function getList() {
    fetch(URL)
      .then(res => {
        return res.json()
      })
      .then(jsonRes => {
        console.log(jsonRes)
        setList(jsonRes.data.channels)
      })
  }

  getList()
}, [])

好抽象。

。

好累

import { useEffect, useState } from "react";
const URL = 'http://geek.itheima.net/v1_0/channels'

function App() {
  //1没用依赖项，初始+组件更新
  const [count, setCount] = useState(0)
  // useEffect(() => {
  //   console.log('useEffect');
  // })
  //是空数组，回调函数只执行一次

  //传入空数组依赖,初始执行一次
  // useEffect(() => {
  //   console.log('useEffect');
  // }, [])

  //传入特定依赖性，初始+依赖项变化时候执行

  useEffect(() => {
    console.log('useEffect');
  }, [count])
  return (
    <div>
      this is App
      <button onClick={() => setCount(count + 1)}>count:{count}</button>
    </div>
  );
}

export default App;

还行

---------------------------------清除副作用
import { useEffect, useState } from "react";
const URL = 'http://geek.itheima.net/v1_0/channels'


function Son() {
  //渲染时开启一个定时器
  useEffect(() => {
    const timer = setInterval(() => {
      console.log('定时器');

    }, 1000)

    return () => {
      //清除副作用
      clearInterval(timer);
    }

  }, [])
  return <div>this is son</div>
}
function App() {
  //通过条件渲染模拟组件卸载
  const [show, setShow] = useState(true)

  return (
    <div>
      {show && <Son />}
      <button onClick={() => setShow(false)}>uninstall</button>
    </div>
  );
}

export default App;

----------------------------------------自定义hook
import { useEffect, useState } from "react";
const URL = 'http://geek.itheima.net/v1_0/channels'

//自定义hook函数
function useToggle() {
  const [value, setValue] = useState()
  const toggle = () => setValue(!value)

  return {
    value,
    toggle
  }

}

function App() {

  const { value, toggle } = useToggle()

  return (
    <div>
      {value && <div>this is div</div>}
      <button onClick={toggle}>toggle</button>
    </div>
  );
}

export default App;

----------------reactHook使用规则
是能在组件中或者其他自定义hook函数中调用
只能在组件的顶层调用，不能嵌套在if for 其他函数中

React 在渲染时是 靠调用顺序来记住你的 Hook 状态 的。
如果把 Hook 写在 if / for / 普通函数中，
会让 Hook 的“顺序”在不同渲染中发生变化，
那 React 就不知道哪个状态对应哪个 Hook 了。